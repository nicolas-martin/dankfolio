// Meme Trading Project .cursorrules
// -------------------------------------------------
// This file defines custom rules for Cursor AI to generate code
// and documentation that align with the Meme Trading project's goals,
// style, and domain-specific requirements.
// -------------------------------------------------

// Project Context & Goals
- The Meme Trading project is a gamified marketplace for trading digital memes.
- It focuses on a playful, engaging user experience while ensuring secure and
  reliable meme transactions.
- The project handles media-rich content (images, animations) and requires dynamic UI updates.

// Code Style & Conventions
- Use clear, descriptive variable and function names related to meme trading (e.g., memeAsset, tradeValidator).
- Write concise, meaningful comments, especially around trade logic, image handling, and user feedback.
- Follow ES6+ syntax and prefer modular code organization (e.g., separate trading logic, API interactions, and UI components).
- For backend code, adhere to RESTful API principles and robust error handling.
- Ensure that code is accessible (include ARIA roles and alternative text for images).

// User Interface Guidelines
- Provide immediate visual feedback on user actions (e.g., drag-and-drop for meme trading).
- Use animations and transitions to enhance the trading experience, but keep performance in mind.
- Maintain a consistent, meme-inspired visual language (e.g., playful icons, vibrant colors).
- Ensure the interface is responsive and accessible across devices.

// Project-Specific Requirements
- Memes should be treated as unique digital assets; include checks for authenticity and ownership.
- Trading operations must validate user credentials and confirm meme availability before processing.
- Optimize media handling for quick load times and smooth rendering.
- Use a modular design to allow future integration with external meme APIs or social platforms.
- Implement rate limiting and spam prevention for meme uploads and trades
- Include versioning system for meme modifications and trade history

// Dependencies & Technology Stack Guidelines
- Frontend: Consider frameworks such as React or Next.js for dynamic UI components.
- Backend: Use Node.js/Express (or your preferred stack) for API endpoints.
- Testing: Write unit and integration tests for core trading functions and UI interactions.
- Asset Storage: Use CDN or specialized storage solutions (e.g., AWS S3) for meme assets
- Caching: Implement Redis or similar for high-performance meme metadata caching

// Cursor AI Specific Instructions
- When generating code, ensure that suggestions include project-specific naming and comments.
- Focus on creating modular, reusable components for trading logic, UI feedback, and data validation.
- Prioritize performance and responsiveness in generated code, especially for asynchronous operations.
- Tailor code examples to reflect the unique aspects of meme trading (e.g., validating meme authenticity, dynamic image rendering).
- Avoid generic boilerplate; always add context or comments that explain how the code relates to meme trading.

// Maintenance & Future Enhancements
- Regularly review and update these rules to reflect changes in project scope or best practices.
- Incorporate user and team feedback to continuously improve the trading experience.
- Align generated code closely with the evolving design guidelines and technical architecture of the project.
- Document all API endpoints and data models in OpenAPI/Swagger format
- Maintain comprehensive test coverage for critical trading functions
- Plan for internationalization support in UI components and content

// Change Log Requirements
- Maintain a CHANGELOG.md file following Keep a Changelog conventions
- Document all significant changes including additions, removals, and breaking changes
- Include version numbers, dates, and descriptions for each release
- Tag changes by category (Added, Changed, Deprecated, Removed, Fixed, Security)
- Link to relevant issue/PR numbers where applicable
- Keep changelog entries user-focused, explaining impact and required actions
- Update changelog before each release or significant feature deployment

// Project specific rules
- The postgres data base should run in a docker, not locally
- There should be 2 distinct postgres instances running in the docker. Port 5432 is the normal one 5434 is the test db
- Only write 1 migration script for now since we have not released it in production. Keep it simple.
- When modifying the model make sure the migration scripts are also updated
- When writing test run the tests and fix any issues that comes up.
- Use a lot of emojis in your responses
- Never add emojis in the backend logs
- To run the backend always use the makefile in `./backend/Makefile run` or using the root makefile `./Makefile run-backend` 
- Do not worry about database, migration or repository for now. Just get everything working in memory we will address storage solution at a later date
- When testing the api make sure to test all endpoints and make sure they are working as expected
- When testing an api, run the related test file in `./backend/scripts/`

// mcp rules
- When you are unsure about the implementation of a go lang package use the go doc mcp 
- When you need to verify the implementation of a go lang package use the go doc mcp 
- When you need to fetch api documentation use the websearch mcp 
- Whenever you use a mcp I want you to tell me and write it in bold in the response. 
- Use the puppeteer mcp to parse github code or other code repositories. 
- When creating a new frontend page, get a design idea by using the puppeteer mcp and stake screenshot of dribble design
