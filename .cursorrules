# Custom Cursor AI Rules for Meme Trading

This file defines custom rules for generating code and documentation that align with meme trading. The format below uses markdown for clear organization.

---

## 1. Code Style & Conventions

- Use clear, descriptive names for variables and functions (e.g., `memeAsset`, `tradeValidator`).
- Write concise comments around trade logic, image handling, and user feedback.
- Use ES6+ syntax with modular code organization for trading logic, API interactions, and UI components.
- For backend code, follow RESTful API principles and robust error handling.

---

## 2. User Interface Guidelines

- Use animations and transitions to improve the trading experience while keeping performance in mind.
- Maintain a consistent, meme-inspired visual language (e.g., playful icons, vibrant colors).
- Build a responsive interface across devices.

---

## 3. Project-Specific Requirements

- Treat memes as unique digital assets; include checks for authenticity and ownership.
- Validate user credentials and confirm meme availability before processing trades.
- Optimize media handling for fast load times and smooth rendering.

---

## 4. Dependencies & Technology Stack Guidelines

- **Frontend:** Use frameworks like React or Next.js for dynamic UI components.
- **Backend:** Use Node.js/Express (or your preferred stack) for API endpoints.
- **Testing:** Write unit and integration tests for core trading functions and UI interactions.
- **Asset Storage:** Use a CDN or specialized storage (e.g., AWS S3) for caching meme assets.

---

## 5. Cursor AI Specific Instructions

- Include project-specific naming and comments in generated code.
- Create modular, reusable components for trading logic, UI feedback, and data validation.
- Focus on performance and responsiveness, especially for asynchronous operations.
- Avoid generic boilerplate; add context or comments relating the code to meme trading.
- Keep summaries brief for minor changes and detailed only for major modifications.

---

## 6. Maintenance & Future Enhancements

- Review and update these rules as project scope or best practices change.
- Align generated code with evolving design guidelines and technical architecture.

---

## 7. Project Specific Rules

- Use emojis in your composer responses.
- Skip database, migration, or repository concerns; work in memory until storage solutions are addressed.
- Test all API endpoints and confirm they function as expected.
- Run related test files in `./backend/scripts/` when testing an API.
- Use a very small default amount for SOLANA: 0.000000001.
- Limit changes strictly to the user's input.
- Avoid over optimizing or over engineering; keep it simple and straight to the point.
- Ask before applying ideas for future proofing.

---

## 8. MCP Rules

- Use the websearch mcp to fetch API documentation. **MCP call executed.**
- Bold any mention of MCP usage in your responses.
- Execute MCP calls automatically without asking the user.

---

## 9. Execution Instructions

- Start the backend with `make run` from the root makefile. This starts the server and holds the console.
- Run the frontend with `make run-mobile` from the root makefile.
- Do not embed direct JavaScript in components or screens. Create code in `./utils` and import it.

---

## 10. Interaction Steps

### 10.1 User Identification

1. Assume you interact with default_user.
2. Identify default_user if not already done.

### 10.2 Memory Retrieval

- Begin with "Remembering..." and fetch all relevant info from your memory (knowledge graph).

### 10.3 Memory

- Track new information on identity, behaviors, preferences, goals, and relationships.

### 10.4 Memory Update

- If you receive new information, update your memory by:
  - Creating entities for recurring organizations, people, and key events.
  - Connecting these entities to current ones using relations.
  - Storing facts as observations.

