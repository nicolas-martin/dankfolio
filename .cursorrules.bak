// Meme Trading Project .cursorrules
// -------------------------------------------------
// This file defines custom rules for Cursor AI to generate code
// and documentation that align with the Meme Trading project's goals,
// style, and domain-specific requirements.
// -------------------------------------------------

// Project Context & Goals
- The Meme Trading project is a gamified marketplace for trading digital memes.
- It focuses on a playful, engaging user experience while ensuring secure and
  reliable meme transactions.
- The project handles media-rich content (images, animations) and requires dynamic UI updates.

// Code Style & Conventions
- Use clear, descriptive variable and function names related to meme trading (e.g., memeAsset, tradeValidator).
- Write concise, meaningful comments, especially around trade logic, image handling, and user feedback.
- Follow ES6+ syntax and prefer modular code organization (e.g., separate trading logic, API interactions, and UI components).
- For backend code, adhere to RESTful API principles and robust error handling.
- Ensure that code is accessible (include ARIA roles and alternative text for images).

// User Interface Guidelines
- Provide immediate visual feedback on user actions (e.g., drag-and-drop for meme trading).
- Use animations and transitions to enhance the trading experience, but keep performance in mind.
- Maintain a consistent, meme-inspired visual language (e.g., playful icons, vibrant colors).
- Ensure the interface is responsive and accessible across devices.

// Project-Specific Requirements
- Memes should be treated as unique digital assets; include checks for authenticity and ownership.
- Trading operations must validate user credentials and confirm meme availability before processing.
- Optimize media handling for quick load times and smooth rendering.
- Use a modular design to allow future integration with external meme APIs or social platforms.
- Implement rate limiting and spam prevention for meme uploads and trades
- Include versioning system for meme modifications and trade history

// Dependencies & Technology Stack Guidelines
- Frontend: Consider frameworks such as React or Next.js for dynamic UI components.
- Backend: Use Node.js/Express (or your preferred stack) for API endpoints.
- Database: Choose scalable solutions (e.g., MongoDB, PostgreSQL) for storing user and meme metadata.
- Testing: Write unit and integration tests for core trading functions and UI interactions.
- Asset Storage: Use CDN or specialized storage solutions (e.g., AWS S3) for meme assets
- Caching: Implement Redis or similar for high-performance meme metadata caching

// Cursor AI Specific Instructions
- When generating code, ensure that suggestions include project-specific naming and comments.
- Focus on creating modular, reusable components for trading logic, UI feedback, and data validation.
- Prioritize performance and responsiveness in generated code, especially for asynchronous operations.
- Tailor code examples to reflect the unique aspects of meme trading (e.g., validating meme authenticity, dynamic image rendering).
- Avoid generic boilerplate; always add context or comments that explain how the code relates to meme trading.

// Maintenance & Future Enhancements
- Regularly review and update these rules to reflect changes in project scope or best practices.
- Incorporate user and team feedback to continuously improve the trading experience.
- Align generated code closely with the evolving design guidelines and technical architecture of the project.
- Document all API endpoints and data models in OpenAPI/Swagger format
- Maintain comprehensive test coverage for critical trading functions
- Plan for internationalization support in UI components and content

// Change Log Requirements
- Maintain a CHANGELOG.md file following Keep a Changelog conventions
- Document all significant changes including additions, removals, and breaking changes
- Include version numbers, dates, and descriptions for each release
- Tag changes by category (Added, Changed, Deprecated, Removed, Fixed, Security)
- Link to relevant issue/PR numbers where applicable
- Keep changelog entries user-focused, explaining impact and required actions
- Update changelog before each release or significant feature deployment

// Database Management & Migration Rules
- Keep database models and migration files synchronized with all schema changes
- Use descriptive names for migrations that clearly indicate their purpose (e.g., AddMemeTradeHistoryTable)
- Include both 'up' and 'down' migrations for all database changes
- Document model relationships and constraints in model files
- Update TypeScript types/interfaces when modifying database schemas
- Run migrations in CI/CD pipeline to catch potential issues early
- Maintain seed data for development and testing environments
- Version control all migration files and track their deployment status
- Back up data before running migrations in production
- Test migrations on staging environment before production deployment
