package coin

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"sort"
	"sync"
	"time"

	"github.com/blocto/solana-go-sdk/client"
	"github.com/blocto/solana-go-sdk/rpc"
	"github.com/nicolas-martin/dankfolio/internal/model"
)

const (
	// CacheExpiration is the duration for which cached data is valid
	CacheExpiration = 5 * time.Minute
	// TrendingDataTTL is the maximum age for the scraped trending data file
	TrendingDataTTL = 24 * time.Hour
	// defaultTrendingTokenPath is the default location if not overridden in config
	defaultTrendingTokenPath = "data/trending_solana_tokens_enriched.json"
	// Initial load timeout
	initialLoadTimeout = 3 * time.Minute // Max time for initial load/scrape
)

// Config holds the configuration for the coin service
type Config struct {
	BirdEyeBaseURL    string
	BirdEyeAPIKey     string
	TrendingTokenPath string // Path to the JSON file generated by the scraper
	CoinGeckoAPIKey   string // Uncomment when needed
	SolanaRPCEndpoint string // Add Solana RPC endpoint needed for enrichment client
}

// Cache represents a cached item with expiration
type Cache struct {
	Data       interface{}
	Expiration time.Time
}

// --- Structs matching the scraper's NEW JSON output (Enriched Data) ---

// EnrichedFileOutput matches the top-level structure of the NEW trending_solana_tokens.json
type EnrichedFileOutput struct {
	ScrapeTimestamp time.Time    `json:"scrapeTimestamp"`
	Tokens          []model.Coin `json:"tokens"` // Contains fully enriched Coin models
}

// --- End scraper JSON structs ---

// Service handles coin-related operations
type Service struct {
	config          *Config
	httpClient      *http.Client
	jupiterClient   *JupiterClient
	solanaRPCClient *client.Client
	coins           map[string]model.Coin
	cache           map[string]Cache
	mu              sync.RWMutex
}

// NewService creates a new CoinService instance
func NewService(config *Config, httpClient *http.Client, jupiterClient *JupiterClient) *Service {
	// Ensure TrendingTokenPath has a default value
	if config.TrendingTokenPath == "" {
		config.TrendingTokenPath = defaultTrendingTokenPath
		log.Printf("TrendingTokenPath not set in config, using default: %s", defaultTrendingTokenPath)
	}

	// Ensure Solana RPC endpoint is set (provide a default or require it)
	if config.SolanaRPCEndpoint == "" {
		config.SolanaRPCEndpoint = rpc.MainnetRPCEndpoint // Default to mainnet
		log.Printf("SolanaRPCEndpoint not set in config, using default: %s", config.SolanaRPCEndpoint)
	}

	// Create Solana RPC client for the service
	solanaRPCClient := client.NewClient(config.SolanaRPCEndpoint)

	service := &Service{
		config:          config,
		httpClient:      httpClient,
		jupiterClient:   jupiterClient,
		solanaRPCClient: solanaRPCClient,
		coins:           make(map[string]model.Coin),
		cache:           make(map[string]Cache),
	}

	// Perform initial data load or refresh, with a timeout
	ctx, cancel := context.WithTimeout(context.Background(), initialLoadTimeout)
	defer cancel()
	if err := service.loadOrRefreshData(ctx); err != nil {
		// Log as warning, not fatal. Service might still work partially with cached/dynamic data.
		log.Printf("Warning: Initial data load/refresh failed: %v", err)
	}

	// TODO: Consider periodic refresh in a background goroutine

	return service
}

// GetCoins returns a list of all available coins
func (s *Service) GetCoins(ctx context.Context) ([]model.Coin, error) {
	coins := make([]model.Coin, 0, len(s.coins))
	for _, coin := range s.coins {
		coins = append(coins, coin)
	}

	sort.Slice(coins, func(i, j int) bool {
		return coins[i].DailyVolume > coins[j].DailyVolume
	})

	return coins, nil
}

// GetCoinByID returns a coin by its ID
func (s *Service) GetCoinByID(ctx context.Context, id string) (*model.Coin, error) {
	s.mu.RLock()
	// Check cache first (might be slightly more up-to-date than file if refreshed recently)
	if cached, exists := s.cache[id]; exists && time.Now().Before(cached.Expiration) {
		if cachedCoin, ok := cached.Data.(model.Coin); ok {
			s.mu.RUnlock()
			log.Printf("GetCoinByID: Cache hit for %s", id)
			return &cachedCoin, nil
		}
	}
	// Check the main map loaded from file
	coin, exists := s.coins[id]
	s.mu.RUnlock()

	if exists {
		log.Printf("GetCoinByID: Found %s in loaded coins map", id)
		// Cache the coin found in the main map if it wasn't in the cache
		s.mu.Lock()
		if _, cacheExists := s.cache[id]; !cacheExists {
			s.cache[id] = Cache{
				Data:       coin,
				Expiration: time.Now().Add(CacheExpiration), // Use standard cache expiration
			}
			log.Printf("GetCoinByID: Added %s to cache from main map", id)
		}
		s.mu.Unlock()
		return &coin, nil
	}

	// --- If not found in cache or file, attempt dynamic enrichment ---
	// This handles cases where a token exists but wasn't in the last scraped/enriched file.
	log.Printf("GetCoinByID: %s not found in cache or file, attempting dynamic enrichment...", id)
	enrichedCoin, err := s.fetchAndCacheCoin(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("coin %s not found and dynamic enrichment failed: %w", id, err)
	}

	// Add the newly enriched coin to the main map and cache
	s.mu.Lock()
	s.coins[id] = *enrichedCoin
	s.cache[id] = Cache{
		Data:       *enrichedCoin,
		Expiration: time.Now().Add(CacheExpiration),
	}
	s.mu.Unlock()
	log.Printf("GetCoinByID: Successfully dynamically enriched and added %s", id)

	return enrichedCoin, nil
}

// GetTokenDetails fetches detailed information about a token
func (s *Service) GetTokenDetails(ctx context.Context, tokenAddress string) (*model.Coin, error) {
	return s.GetCoinByID(ctx, tokenAddress)
}

// fetchAndCacheCoin handles caching and calls the core EnrichCoinData function.
// This is used for dynamically enriching tokens not found in the initial file load.
// Renamed from enrichCoin
func (s *Service) fetchAndCacheCoin(ctx context.Context, mintAddress string) (*model.Coin, error) {
	// Check cache first
	s.mu.RLock()
	if cached, exists := s.cache[mintAddress]; exists && time.Now().Before(cached.Expiration) {
		if cachedCoin, ok := cached.Data.(model.Coin); ok {
			s.mu.RUnlock()
			log.Printf("fetchAndCacheCoin: Cache hit for %s", mintAddress) // Updated log message
			return &cachedCoin, nil
		}
	}
	s.mu.RUnlock()

	log.Printf("fetchAndCacheCoin: Cache miss for %s, calling EnrichCoinData...", mintAddress) // Updated log message
	// Call the exported enrichment function from enrich.go, passing the service's clients
	// Provide empty initial values as we don't have scraped data in this context (dynamic enrichment)
	enrichedCoin, err := EnrichCoinData(
		ctx,
		mintAddress,
		"", // No initial name
		"", // No initial icon
		0,  // No initial volume
		s.jupiterClient,
		s.httpClient,
		s.solanaRPCClient,
	)
	if err != nil {
		// Don't cache errors persistently here, allow retry on next request
		log.Printf("ERROR: fetchAndCacheCoin: Failed to enrich %s: %v", mintAddress, err) // Updated log message
		return nil, fmt.Errorf("failed to enrich coin %s: %w", mintAddress, err)
	}

	// Cache the successfully enriched coin
	s.mu.Lock()
	s.cache[mintAddress] = Cache{
		Data:       *enrichedCoin,
		Expiration: time.Now().Add(CacheExpiration),
	}
	s.mu.Unlock()
	log.Printf("fetchAndCacheCoin: Successfully enriched and cached %s", mintAddress) // Updated log message

	return enrichedCoin, nil
}

// loadOrRefreshData checks if the trending data file is fresh. If not, it triggers
// a scrape and enrichment process before loading the data into the service.
func (s *Service) loadOrRefreshData(ctx context.Context) error {
	log.Println("Checking freshness of trending coin data file...")
	filePath := s.config.TrendingTokenPath
	needsRefresh := false

	fileInfo, err := os.Stat(filePath)
	if err != nil {
		if os.IsNotExist(err) {
			log.Printf("Trending data file not found at %s. Triggering refresh.", filePath)
			needsRefresh = true
		} else {
			// Other error accessing file stat (permissions?), log warning but attempt load anyway
			log.Printf("WARN: Error checking file stat for %s: %v. Attempting to load anyway.", filePath, err)
		}
	} else {
		// File exists, check its modification time
		if time.Since(fileInfo.ModTime()) > TrendingDataTTL {
			log.Printf("Trending data file %s is older than TTL (%v). Triggering refresh.", filePath, TrendingDataTTL)
			needsRefresh = true
		} else {
			log.Printf("Trending data file %s is fresh (ModTime: %s). Skipping refresh.", filePath, fileInfo.ModTime().Format(time.RFC3339))
		}
	}

	// --- Perform scrape if needed ---
	if needsRefresh {
		log.Println("Attempting to scrape and enrich new trending data...")
		// Use the context passed to loadOrRefreshData for the scrape operation
		if scrapeErr := s.scrapeAndEnrichToFile(ctx); scrapeErr != nil {
			// Log the scraping error, but DO NOT return immediately.
			// We still want to try loading whatever data might exist (even if stale).
			log.Printf("ERROR: Scraping and enrichment failed: %v. Will attempt to load existing data.", scrapeErr)
			// Optionally, return the error if loading stale data is unacceptable
			// return fmt.Errorf("scraping failed, cannot proceed: %w", scrapeErr)
		} else {
			log.Println("Scraping and enrichment completed successfully.")
		}
	}

	// --- Load data from file (always attempt after checking/refreshing) ---
	log.Println("Loading enriched coin data from file...")
	enrichedCoins, timestamp, loadErr := s.loadEnrichedCoinsFromFile()
	if loadErr != nil {
		// If scraping was needed but failed, and loading also fails, return the load error.
		// If the file just doesn't exist after a failed scrape, this loadErr will reflect that.
		log.Printf("ERROR: Failed to load enriched coins from file %s: %v", filePath, loadErr)
		if needsRefresh && err != nil { // If refresh was needed and stat failed initially
			return fmt.Errorf("initial file stat error: %v, and subsequent load failed: %w", err, loadErr)
		}
		return fmt.Errorf("failed to load enriched coins from file: %w", loadErr)
	}

	s.mu.Lock()
	defer s.mu.Unlock()

	// Replace the existing map with the newly loaded data
	s.coins = make(map[string]model.Coin, len(enrichedCoins))
	for _, coin := range enrichedCoins {
		s.coins[coin.ID] = coin
	}

	log.Printf("Coin map refresh complete from file (Timestamp: %s). Total coins loaded: %d",
		timestamp.Format(time.RFC3339), len(s.coins))

	// Optional: Clear the dynamic cache after a successful load/refresh?
	// This ensures the cache doesn't contain stale dynamically fetched items.
	s.cache = make(map[string]Cache)
	log.Println("Dynamic coin cache cleared after loading data from file.")

	return nil // Success
}

// loadEnrichedCoinsFromFile reads and parses the JSON file containing pre-enriched Coin data.
func (s *Service) loadEnrichedCoinsFromFile() ([]model.Coin, time.Time, error) {
	filePath := s.config.TrendingTokenPath
	log.Printf("Attempting to load enriched coins from: %s", filePath)

	fileData, err := os.ReadFile(filePath)
	if err != nil {
		// Return specific error for not found, caller handles it
		if os.IsNotExist(err) {
			return nil, time.Time{}, fmt.Errorf("enriched coin file not found at %s: %w", filePath, err)
		}
		return nil, time.Time{}, fmt.Errorf("error reading enriched coin file %s: %w", filePath, err)
	}

	if len(fileData) == 0 {
		log.Printf("WARN: Enriched coin file %s is empty.", filePath)
		return []model.Coin{}, time.Time{}, nil // Return empty list, not error
	}

	var fileOutput EnrichedFileOutput // Use the struct defined in this file
	err = json.Unmarshal(fileData, &fileOutput)
	if err != nil {
		log.Printf("ERROR: Error unmarshalling enriched coin data from %s: %v", filePath, err)
		// Attempt to log the problematic data snippet if possible (be careful with large files)
		// preview := string(fileData)
		// if len(preview) > 200 { preview = preview[:200] + "..." }
		// log.Printf("Data preview: %s", preview)
		return nil, time.Time{}, fmt.Errorf("failed to decode enriched JSON from %s: %w", filePath, err)
	}

	// Log timestamp from file
	if fileOutput.ScrapeTimestamp.IsZero() {
		log.Printf("WARN: Enriched coin file %s has zero timestamp in JSON.", filePath)
	} else {
		log.Printf("Successfully decoded enriched coin data from %s (JSON Timestamp: %s)",
			filePath, fileOutput.ScrapeTimestamp.Format(time.RFC3339))
	}

	if len(fileOutput.Tokens) == 0 {
		log.Printf("WARN: Enriched coin file %s contained zero tokens in the 'tokens' list.", filePath)
		// Return empty slice, not an error
	}

	return fileOutput.Tokens, fileOutput.ScrapeTimestamp, nil
}

// --- Removed parseVolume, moved to scraper.go ---
// --- Removed scraper constants, moved to scraper.go ---
