package coin

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/blocto/solana-go-sdk/client"
	"github.com/blocto/solana-go-sdk/common"
	"github.com/blocto/solana-go-sdk/program/metaplex/token_metadata"
	"github.com/blocto/solana-go-sdk/rpc"
	"github.com/nicolas-martin/dankfolio/internal/model"
)

const (
	// CacheExpiration is the duration for which cached data is valid
	CacheExpiration = 5 * time.Minute
	// TrendingDataTTL is the maximum age for the scraped trending data file
	TrendingDataTTL = 1 * time.Hour
	// defaultTrendingTokenPath is the default location if not overridden in config
	defaultTrendingTokenPath = "data/trending_solana_tokens.json"
)

// Config holds the configuration for the coin service
type Config struct {
	BirdEyeBaseURL    string
	BirdEyeAPIKey     string
	TrendingTokenPath string // Path to the JSON file generated by the scraper
	CoinGeckoAPIKey   string // Uncomment when needed
}

// Cache represents a cached item with expiration
type Cache struct {
	Data       interface{}
	Expiration time.Time
}

// --- Structs matching the scraper's JSON output ---

// ScrapeOutput matches the top-level structure of trending_solana_tokens.json
type ScrapeOutput struct {
	ScrapeTimestamp time.Time                   `json:"scrapeTimestamp"`
	Tokens          map[string]ScrapedTokenInfo `json:"tokens"`
}

// ScrapedTokenInfo matches the individual token details in the JSON
type ScrapedTokenInfo struct {
	Name    string `json:"Name"`
	Volume  string `json:"Volume"` // Volume as string (e.g., "$1.23M")
	IconURL string `json:"IconURL"`
}

// --- End scraper JSON structs ---

// Service handles coin-related operations
type Service struct {
	config        *Config
	httpClient    *http.Client
	jupiterClient *JupiterClient
	coins         map[string]model.Coin
	cache         map[string]Cache
	mu            sync.RWMutex
}

// NewService creates a new CoinService instance
func NewService(config *Config, httpClient *http.Client, jupiterClient *JupiterClient) *Service {
	// Ensure TrendingTokenPath has a default value
	if config.TrendingTokenPath == "" {
		config.TrendingTokenPath = defaultTrendingTokenPath
		log.Printf("TrendingTokenPath not set in config, using default: %s", defaultTrendingTokenPath)
	}

	service := &Service{
		config:        config,
		httpClient:    httpClient,
		jupiterClient: jupiterClient,
		coins:         make(map[string]model.Coin),
		cache:         make(map[string]Cache),
	}

	if err := service.refreshCoins(); err != nil {
		// Log as warning, not fatal. Service might still work partially.
		log.Printf("Warning: Initial coin refresh failed: %v", err)
	}

	// TODO: Consider periodic refresh in a goroutine

	return service
}

// GetCoins returns a list of all available coins
func (s *Service) GetCoins(ctx context.Context) ([]model.Coin, error) {
	coins := make([]model.Coin, 0, len(s.coins))
	for _, coin := range s.coins {
		coins = append(coins, coin)
	}

	sort.Slice(coins, func(i, j int) bool {
		return coins[i].DailyVolume > coins[j].DailyVolume
	})

	return coins, nil
}

// GetCoinByID returns a coin by its ID
func (s *Service) GetCoinByID(ctx context.Context, id string) (*model.Coin, error) {
	s.mu.RLock()
	coin, exists := s.coins[id]
	s.mu.RUnlock()

	if exists {
		// Even if the coin exists, we need to ensure it's enriched
		if err := s.enrichCoin(&coin); err != nil {
			return nil, fmt.Errorf("failed to enrich existing coin %s: %w", id, err)
		}
		s.mu.Lock()
		s.coins[id] = coin // Store the enriched version back
		s.mu.Unlock()
		return &coin, nil
	}

	coin = model.Coin{ID: id}
	if err := s.enrichCoin(&coin); err != nil {
		return nil, fmt.Errorf("failed to fetch coin %s: %w", id, err)
	}

	s.mu.Lock()
	s.coins[id] = coin
	s.mu.Unlock()
	return &coin, nil
}

// GetTokenDetails fetches detailed information about a token
func (s *Service) GetTokenDetails(ctx context.Context, tokenAddress string) (*model.Coin, error) {
	return s.GetCoinByID(ctx, tokenAddress)
}

// enrichCoin enriches a coin with data from Jupiter and IPFS
func (s *Service) enrichCoin(coin *model.Coin) error {
	// Check cache first
	s.mu.RLock()
	if cached, exists := s.cache[coin.ID]; exists && time.Now().Before(cached.Expiration) {
		if cachedCoin, ok := cached.Data.(model.Coin); ok {
			*coin = cachedCoin // Copy all fields from cached coin
			s.mu.RUnlock()
			return nil
		}
	}
	s.mu.RUnlock()

	// Get Jupiter data for basic info
	log.Printf("Fetching Jupiter token info for %s (%s)", coin.Symbol, coin.ID)
	jupiterInfo, err := s.jupiterClient.GetTokenInfo(coin.ID)
	if err != nil {
		return fmt.Errorf("failed to get Jupiter info: %w", err)
	}
	log.Printf("Got Jupiter token info for %s: %s (%s)", coin.ID, jupiterInfo.Name, jupiterInfo.Symbol)

	// Basic info from Jupiter
	coin.Name = jupiterInfo.Name
	coin.Symbol = jupiterInfo.Symbol
	coin.Decimals = jupiterInfo.Decimals
	coin.DailyVolume = jupiterInfo.DailyVolume
	coin.Tags = jupiterInfo.Tags
	coin.IconUrl = jupiterInfo.LogoURI
	coin.CreatedAt = jupiterInfo.CreatedAt

	// Get price from Jupiter
	log.Printf("Fetching Jupiter price for %s (%s)", coin.Symbol, coin.ID)
	prices, err := s.jupiterClient.GetTokenPrices([]string{coin.ID})
	if err != nil {
		log.Printf("Warning: Error fetching price for %s: %v", coin.ID, err)
	} else {
		// NOTE: lower case?
		price := prices[coin.ID]
		coin.Price = price
		log.Printf("Got Jupiter price for %s: %f", coin.ID, price)
	}

	// Get metadata account for the token
	metadataAccount, err := s.getMetadataAccount(coin.ID)
	if err != nil {
		log.Printf("Warning: Error fetching metadata for %s: %v", coin.ID, err)
		return nil // Not all tokens have metadata, so this is not a fatal error
	}

	// Fetch off-chain metadata
	uri := resolveIPFSGateway(metadataAccount.Data.Uri)
	metadata, err := fetchOffChainMetadataWithFallback(uri)
	if err != nil {
		log.Printf("Warning: Error fetching off-chain metadata for %s: %v", coin.ID, err)
	}

	// Enrich with metadata
	s.enrichFromMetadata(coin, metadata)

	// Cache the fully enriched coin
	s.mu.Lock()
	s.cache[coin.ID] = Cache{
		Data:       *coin,
		Expiration: time.Now().Add(CacheExpiration),
	}
	s.mu.Unlock()

	return nil
}

// enrichFromMetadata updates coin fields from metadata
func (s *Service) enrichFromMetadata(coin *model.Coin, metadata map[string]interface{}) {
	if description, ok := metadata["description"].(string); ok {
		coin.Description = description
	} else {
		coin.Description = fmt.Sprintf("%s (%s) is a Solana token.", coin.Name, coin.Symbol)
	}

	// Handle website field with multiple possible names
	if website, ok := metadata["website"].(string); ok {
		coin.Website = website
	} else if website, ok := metadata["external_url"].(string); ok {
		coin.Website = website
	} else if website, ok := metadata["createdOn"].(string); ok {
		coin.Website = website
	}

	// Image/Icon URL (only if not set by Jupiter)
	if coin.IconUrl == "" {
		if image, ok := metadata["image"].(string); ok {
			coin.IconUrl = image
		}
	}

	// Social links
	if twitter, ok := metadata["twitter"].(string); ok {
		coin.Twitter = twitter
	}
	if telegram, ok := metadata["telegram"].(string); ok {
		coin.Telegram = telegram
	}

	// Check attributes array as fallback
	if attributes, ok := metadata["attributes"].([]interface{}); ok {
		for _, attr := range attributes {
			if attrMap, ok := attr.(map[string]interface{}); ok {
				trait := fmt.Sprintf("%v", attrMap["trait_type"])
				value := fmt.Sprintf("%v", attrMap["value"])
				switch strings.ToLower(trait) {
				case "twitter":
					if coin.Twitter == "" {
						coin.Twitter = value
					}
				case "telegram":
					if coin.Telegram == "" {
						coin.Telegram = value
					}
				}
			}
		}
	}
}

// refreshCoins updates the coin list by loading from the trending tokens file
// and then enriches each coin with details from Jupiter and metadata.
func (s *Service) refreshCoins() error {
	log.Println("Refreshing coins from trending token file...")
	trendingTokens, _, err := s.loadTrendingTokensFromFile()
	if err != nil {
		// If the file doesn't exist, we might not want to treat it as a fatal error
		// depending on requirements. For now, we return the error.
		return fmt.Errorf("failed to load trending tokens: %w", err)
	}

	// Create a temporary map to hold the coins during enrichment
	enrichedCoins := make(map[string]model.Coin)
	var enrichedCount int
	var failedCount int

	log.Printf("Attempting to enrich %d trending tokens...", len(trendingTokens))
	for mintAddr, tokenInfo := range trendingTokens {
		volume, _ := parseVolume(tokenInfo.Volume) // Ignore error for now, default to 0

		// Create a basic Coin model first
		coin := model.Coin{
			ID:          mintAddr,
			Name:        tokenInfo.Name,
			Symbol:      "", // Will be filled by enrichCoin
			IconUrl:     tokenInfo.IconURL,
			DailyVolume: volume,
		}

		// Enrich the coin. enrichCoin handles caching internally.
		// We pass a pointer to allow enrichCoin to modify the coin directly.
		err = s.enrichCoin(&coin)
		if err != nil {
			// Log enrichment errors but don't stop the whole refresh process
			log.Printf("WARN: Failed to enrich coin %s (%s): %v", tokenInfo.Name, mintAddr, err)
			failedCount++
			// Optionally skip adding failed coins: continue
		}

		// Store the potentially enriched (or basic if enrichment failed) coin
		enrichedCoins[mintAddr] = coin
		if err == nil {
			enrichedCount++
		}
	}

	// Now, update the service's main coin map under a lock
	s.mu.Lock()
	s.coins = enrichedCoins // Replace the old map with the newly enriched one
	s.mu.Unlock()

	log.Printf("Coin map refresh complete. Total coins: %d (Enriched: %d, Failed: %d)", len(s.coins), enrichedCount, failedCount)
	return nil
}

// loadTrendingTokensFromFile reads and parses the JSON file generated by the scraper.
func (s *Service) loadTrendingTokensFromFile() (map[string]ScrapedTokenInfo, time.Time, error) {
	filePath := s.config.TrendingTokenPath
	log.Printf("Attempting to load trending tokens from: %s", filePath)

	fileData, err := os.ReadFile(filePath)
	if err != nil {
		if os.IsNotExist(err) {
			log.Printf("Trending token file not found at %s. Cannot load initial coin list.", filePath)
			return nil, time.Time{}, fmt.Errorf("trending token file not found: %s", filePath)
		}
		return nil, time.Time{}, fmt.Errorf("error reading trending token file %s: %w", filePath, err)
	}

	var scrapeData ScrapeOutput
	err = json.Unmarshal(fileData, &scrapeData)
	if err != nil {
		log.Printf("Error unmarshalling trending token data from %s: %v", filePath, err)
		return nil, time.Time{}, fmt.Errorf("failed to decode trending JSON from %s: %w", filePath, err)
	}

	// Check timestamp
	if time.Since(scrapeData.ScrapeTimestamp) > TrendingDataTTL {
		log.Printf("WARN: Trending token data in %s is older than TTL (%v). Scraped at: %s",
			filePath, TrendingDataTTL, scrapeData.ScrapeTimestamp.Format(time.RFC3339))
		// Proceed with stale data, but log warning
	} else {
		log.Printf("Loaded fresh trending token data from %s (scraped at %s)",
			filePath, scrapeData.ScrapeTimestamp.Format(time.RFC3339))
	}

	if len(scrapeData.Tokens) == 0 {
		log.Printf("WARN: Trending token file %s contained no tokens.", filePath)
		// Return empty map, not an error
	}

	return scrapeData.Tokens, scrapeData.ScrapeTimestamp, nil
}

// parseVolume converts volume strings like "$1.23M", "$500.5K", "$100" to float64
func parseVolume(volumeStr string) (float64, error) {
	volumeStr = strings.TrimPrefix(volumeStr, "$")
	multiplier := 1.0

	if strings.HasSuffix(volumeStr, "M") {
		multiplier = 1_000_000
		volumeStr = strings.TrimSuffix(volumeStr, "M")
	} else if strings.HasSuffix(volumeStr, "K") {
		multiplier = 1_000
		volumeStr = strings.TrimSuffix(volumeStr, "K")
	}

	volume, err := strconv.ParseFloat(volumeStr, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to parse volume value '%s': %w", volumeStr, err)
	}

	return volume * multiplier, nil
}

// resolveIPFSGateway rewrites the URI if it uses a known gateway that might be unreliable.
func resolveIPFSGateway(uri string) string {
	if strings.Contains(uri, "/ipfs/") {
		parts := strings.Split(uri, "/ipfs/")
		if len(parts) >= 2 {
			cid := parts[1]
			return "ipfs://" + cid
		}
	}
	return uri
}

// fetchOffChainMetadataWithFallback attempts to fetch off-chain metadata
// using a list of HTTP gateways as fallback for IPFS content.
func fetchOffChainMetadataWithFallback(uri string) (map[string]interface{}, error) {
	var offchainMeta map[string]interface{}

	if strings.HasPrefix(uri, "ipfs://") {
		cid := strings.TrimPrefix(uri, "ipfs://")
		gateways := []string{
			"https://ipfs.io/ipfs/",
			"https://dweb.link/ipfs/",
			"https://cloudflare-ipfs.com/ipfs/",
		}
		var err error
		for _, gw := range gateways {
			fullURL := gw + cid
			log.Printf("Attempting gateway: %s", fullURL)
			offchainMeta, err = fetchOffChainMetadataHTTP(fullURL)
			if err == nil {
				return offchainMeta, nil
			}
			log.Printf("Gateway %s failed: %v", gw, err)
		}
		return nil, err
	}

	if strings.HasPrefix(uri, "http") {
		return fetchOffChainMetadataHTTP(uri)
	}

	return nil, nil
}

// fetchOffChainMetadataHTTP fetches JSON metadata from the given HTTP URL.
func fetchOffChainMetadataHTTP(url string) (map[string]interface{}, error) {
	var offchainMeta map[string]interface{}
	client := http.Client{
		Timeout: 10 * time.Second,
	}
	resp, err := client.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("HTTP status %d", resp.StatusCode)
	}
	if err := json.NewDecoder(resp.Body).Decode(&offchainMeta); err != nil {
		return nil, err
	}
	return offchainMeta, nil
}

// getMetadataAccount retrieves the metadata account for a token
func (s *Service) getMetadataAccount(mint string) (*token_metadata.Metadata, error) {
	mintPubkey := common.PublicKeyFromString(mint)
	metadataAccount, err := token_metadata.GetTokenMetaPubkey(mintPubkey)
	if err != nil {
		return nil, fmt.Errorf("failed to get metadata account: %w", err)
	}

	c := client.NewClient(rpc.MainnetRPCEndpoint)
	accountInfo, err := c.GetAccountInfo(context.Background(), metadataAccount.ToBase58())
	if err != nil {
		return nil, fmt.Errorf("failed to get account info: %w", err)
	}

	metadata, err := token_metadata.MetadataDeserialize(accountInfo.Data)
	if err != nil {
		return nil, fmt.Errorf("failed to parse metadata: %w", err)
	}

	return &metadata, nil
}
