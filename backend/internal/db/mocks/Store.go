// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package dbmocks

import (
	"context"

	"github.com/nicolas-martin/dankfolio/backend/internal/db"
	"github.com/nicolas-martin/dankfolio/backend/internal/model"
	mock "github.com/stretchr/testify/mock"
)

// NewMockStore creates a new instance of MockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStore {
	mock := &MockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStore is an autogenerated mock type for the Store type
type MockStore struct {
	mock.Mock
}

type MockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStore) EXPECT() *MockStore_Expecter {
	return &MockStore_Expecter{mock: &_m.Mock}
}

// ApiStats provides a mock function for the type MockStore
func (_mock *MockStore) ApiStats() db.Repository[model.ApiStat] {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ApiStats")
	}

	var r0 db.Repository[model.ApiStat]
	if returnFunc, ok := ret.Get(0).(func() db.Repository[model.ApiStat]); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(db.Repository[model.ApiStat])
		}
	}
	return r0
}

// MockStore_ApiStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApiStats'
type MockStore_ApiStats_Call struct {
	*mock.Call
}

// ApiStats is a helper method to define mock.On call
func (_e *MockStore_Expecter) ApiStats() *MockStore_ApiStats_Call {
	return &MockStore_ApiStats_Call{Call: _e.mock.On("ApiStats")}
}

func (_c *MockStore_ApiStats_Call) Run(run func()) *MockStore_ApiStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_ApiStats_Call) Return(repository db.Repository[model.ApiStat]) *MockStore_ApiStats_Call {
	_c.Call.Return(repository)
	return _c
}

func (_c *MockStore_ApiStats_Call) RunAndReturn(run func() db.Repository[model.ApiStat]) *MockStore_ApiStats_Call {
	_c.Call.Return(run)
	return _c
}

// Coins provides a mock function for the type MockStore
func (_mock *MockStore) Coins() db.Repository[model.Coin] {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Coins")
	}

	var r0 db.Repository[model.Coin]
	if returnFunc, ok := ret.Get(0).(func() db.Repository[model.Coin]); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(db.Repository[model.Coin])
		}
	}
	return r0
}

// MockStore_Coins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Coins'
type MockStore_Coins_Call struct {
	*mock.Call
}

// Coins is a helper method to define mock.On call
func (_e *MockStore_Expecter) Coins() *MockStore_Coins_Call {
	return &MockStore_Coins_Call{Call: _e.mock.On("Coins")}
}

func (_c *MockStore_Coins_Call) Run(run func()) *MockStore_Coins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_Coins_Call) Return(repository db.Repository[model.Coin]) *MockStore_Coins_Call {
	_c.Call.Return(repository)
	return _c
}

func (_c *MockStore_Coins_Call) RunAndReturn(run func() db.Repository[model.Coin]) *MockStore_Coins_Call {
	_c.Call.Return(run)
	return _c
}

// ListNewestCoins provides a mock function for the type MockStore
func (_mock *MockStore) ListNewestCoins(ctx context.Context, opts db.ListOptions) ([]model.Coin, int32, error) {
	ret := _mock.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ListNewestCoins")
	}

	var r0 []model.Coin
	var r1 int32
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, db.ListOptions) ([]model.Coin, int32, error)); ok {
		return returnFunc(ctx, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, db.ListOptions) []model.Coin); ok {
		r0 = returnFunc(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Coin)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, db.ListOptions) int32); ok {
		r1 = returnFunc(ctx, opts)
	} else {
		r1 = ret.Get(1).(int32)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, db.ListOptions) error); ok {
		r2 = returnFunc(ctx, opts)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockStore_ListNewestCoins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListNewestCoins'
type MockStore_ListNewestCoins_Call struct {
	*mock.Call
}

// ListNewestCoins is a helper method to define mock.On call
//   - ctx context.Context
//   - opts db.ListOptions
func (_e *MockStore_Expecter) ListNewestCoins(ctx interface{}, opts interface{}) *MockStore_ListNewestCoins_Call {
	return &MockStore_ListNewestCoins_Call{Call: _e.mock.On("ListNewestCoins", ctx, opts)}
}

func (_c *MockStore_ListNewestCoins_Call) Run(run func(ctx context.Context, opts db.ListOptions)) *MockStore_ListNewestCoins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 db.ListOptions
		if args[1] != nil {
			arg1 = args[1].(db.ListOptions)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_ListNewestCoins_Call) Return(coins []model.Coin, n int32, err error) *MockStore_ListNewestCoins_Call {
	_c.Call.Return(coins, n, err)
	return _c
}

func (_c *MockStore_ListNewestCoins_Call) RunAndReturn(run func(ctx context.Context, opts db.ListOptions) ([]model.Coin, int32, error)) *MockStore_ListNewestCoins_Call {
	_c.Call.Return(run)
	return _c
}

// ListTopGainersCoins provides a mock function for the type MockStore
func (_mock *MockStore) ListTopGainersCoins(ctx context.Context, opts db.ListOptions) ([]model.Coin, int32, error) {
	ret := _mock.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ListTopGainersCoins")
	}

	var r0 []model.Coin
	var r1 int32
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, db.ListOptions) ([]model.Coin, int32, error)); ok {
		return returnFunc(ctx, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, db.ListOptions) []model.Coin); ok {
		r0 = returnFunc(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Coin)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, db.ListOptions) int32); ok {
		r1 = returnFunc(ctx, opts)
	} else {
		r1 = ret.Get(1).(int32)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, db.ListOptions) error); ok {
		r2 = returnFunc(ctx, opts)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockStore_ListTopGainersCoins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTopGainersCoins'
type MockStore_ListTopGainersCoins_Call struct {
	*mock.Call
}

// ListTopGainersCoins is a helper method to define mock.On call
//   - ctx context.Context
//   - opts db.ListOptions
func (_e *MockStore_Expecter) ListTopGainersCoins(ctx interface{}, opts interface{}) *MockStore_ListTopGainersCoins_Call {
	return &MockStore_ListTopGainersCoins_Call{Call: _e.mock.On("ListTopGainersCoins", ctx, opts)}
}

func (_c *MockStore_ListTopGainersCoins_Call) Run(run func(ctx context.Context, opts db.ListOptions)) *MockStore_ListTopGainersCoins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 db.ListOptions
		if args[1] != nil {
			arg1 = args[1].(db.ListOptions)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_ListTopGainersCoins_Call) Return(coins []model.Coin, n int32, err error) *MockStore_ListTopGainersCoins_Call {
	_c.Call.Return(coins, n, err)
	return _c
}

func (_c *MockStore_ListTopGainersCoins_Call) RunAndReturn(run func(ctx context.Context, opts db.ListOptions) ([]model.Coin, int32, error)) *MockStore_ListTopGainersCoins_Call {
	_c.Call.Return(run)
	return _c
}

// ListTrendingCoins provides a mock function for the type MockStore
func (_mock *MockStore) ListTrendingCoins(ctx context.Context, opts db.ListOptions) ([]model.Coin, int32, error) {
	ret := _mock.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ListTrendingCoins")
	}

	var r0 []model.Coin
	var r1 int32
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, db.ListOptions) ([]model.Coin, int32, error)); ok {
		return returnFunc(ctx, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, db.ListOptions) []model.Coin); ok {
		r0 = returnFunc(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Coin)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, db.ListOptions) int32); ok {
		r1 = returnFunc(ctx, opts)
	} else {
		r1 = ret.Get(1).(int32)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, db.ListOptions) error); ok {
		r2 = returnFunc(ctx, opts)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockStore_ListTrendingCoins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTrendingCoins'
type MockStore_ListTrendingCoins_Call struct {
	*mock.Call
}

// ListTrendingCoins is a helper method to define mock.On call
//   - ctx context.Context
//   - opts db.ListOptions
func (_e *MockStore_Expecter) ListTrendingCoins(ctx interface{}, opts interface{}) *MockStore_ListTrendingCoins_Call {
	return &MockStore_ListTrendingCoins_Call{Call: _e.mock.On("ListTrendingCoins", ctx, opts)}
}

func (_c *MockStore_ListTrendingCoins_Call) Run(run func(ctx context.Context, opts db.ListOptions)) *MockStore_ListTrendingCoins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 db.ListOptions
		if args[1] != nil {
			arg1 = args[1].(db.ListOptions)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_ListTrendingCoins_Call) Return(coins []model.Coin, n int32, err error) *MockStore_ListTrendingCoins_Call {
	_c.Call.Return(coins, n, err)
	return _c
}

func (_c *MockStore_ListTrendingCoins_Call) RunAndReturn(run func(ctx context.Context, opts db.ListOptions) ([]model.Coin, int32, error)) *MockStore_ListTrendingCoins_Call {
	_c.Call.Return(run)
	return _c
}

// NaughtyWords provides a mock function for the type MockStore
func (_mock *MockStore) NaughtyWords() db.Repository[model.NaughtyWord] {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for NaughtyWords")
	}

	var r0 db.Repository[model.NaughtyWord]
	if returnFunc, ok := ret.Get(0).(func() db.Repository[model.NaughtyWord]); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(db.Repository[model.NaughtyWord])
		}
	}
	return r0
}

// MockStore_NaughtyWords_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NaughtyWords'
type MockStore_NaughtyWords_Call struct {
	*mock.Call
}

// NaughtyWords is a helper method to define mock.On call
func (_e *MockStore_Expecter) NaughtyWords() *MockStore_NaughtyWords_Call {
	return &MockStore_NaughtyWords_Call{Call: _e.mock.On("NaughtyWords")}
}

func (_c *MockStore_NaughtyWords_Call) Run(run func()) *MockStore_NaughtyWords_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_NaughtyWords_Call) Return(repository db.Repository[model.NaughtyWord]) *MockStore_NaughtyWords_Call {
	_c.Call.Return(repository)
	return _c
}

func (_c *MockStore_NaughtyWords_Call) RunAndReturn(run func() db.Repository[model.NaughtyWord]) *MockStore_NaughtyWords_Call {
	_c.Call.Return(run)
	return _c
}

// SearchCoins provides a mock function for the type MockStore
func (_mock *MockStore) SearchCoins(ctx context.Context, query string, tags []string, minVolume24h float64, limit int32, offset int32, sortBy string, sortDesc bool) ([]model.Coin, error) {
	ret := _mock.Called(ctx, query, tags, minVolume24h, limit, offset, sortBy, sortDesc)

	if len(ret) == 0 {
		panic("no return value specified for SearchCoins")
	}

	var r0 []model.Coin
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []string, float64, int32, int32, string, bool) ([]model.Coin, error)); ok {
		return returnFunc(ctx, query, tags, minVolume24h, limit, offset, sortBy, sortDesc)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []string, float64, int32, int32, string, bool) []model.Coin); ok {
		r0 = returnFunc(ctx, query, tags, minVolume24h, limit, offset, sortBy, sortDesc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Coin)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, []string, float64, int32, int32, string, bool) error); ok {
		r1 = returnFunc(ctx, query, tags, minVolume24h, limit, offset, sortBy, sortDesc)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_SearchCoins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchCoins'
type MockStore_SearchCoins_Call struct {
	*mock.Call
}

// SearchCoins is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
//   - tags []string
//   - minVolume24h float64
//   - limit int32
//   - offset int32
//   - sortBy string
//   - sortDesc bool
func (_e *MockStore_Expecter) SearchCoins(ctx interface{}, query interface{}, tags interface{}, minVolume24h interface{}, limit interface{}, offset interface{}, sortBy interface{}, sortDesc interface{}) *MockStore_SearchCoins_Call {
	return &MockStore_SearchCoins_Call{Call: _e.mock.On("SearchCoins", ctx, query, tags, minVolume24h, limit, offset, sortBy, sortDesc)}
}

func (_c *MockStore_SearchCoins_Call) Run(run func(ctx context.Context, query string, tags []string, minVolume24h float64, limit int32, offset int32, sortBy string, sortDesc bool)) *MockStore_SearchCoins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []string
		if args[2] != nil {
			arg2 = args[2].([]string)
		}
		var arg3 float64
		if args[3] != nil {
			arg3 = args[3].(float64)
		}
		var arg4 int32
		if args[4] != nil {
			arg4 = args[4].(int32)
		}
		var arg5 int32
		if args[5] != nil {
			arg5 = args[5].(int32)
		}
		var arg6 string
		if args[6] != nil {
			arg6 = args[6].(string)
		}
		var arg7 bool
		if args[7] != nil {
			arg7 = args[7].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
			arg7,
		)
	})
	return _c
}

func (_c *MockStore_SearchCoins_Call) Return(coins []model.Coin, err error) *MockStore_SearchCoins_Call {
	_c.Call.Return(coins, err)
	return _c
}

func (_c *MockStore_SearchCoins_Call) RunAndReturn(run func(ctx context.Context, query string, tags []string, minVolume24h float64, limit int32, offset int32, sortBy string, sortDesc bool) ([]model.Coin, error)) *MockStore_SearchCoins_Call {
	_c.Call.Return(run)
	return _c
}

// Trades provides a mock function for the type MockStore
func (_mock *MockStore) Trades() db.Repository[model.Trade] {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Trades")
	}

	var r0 db.Repository[model.Trade]
	if returnFunc, ok := ret.Get(0).(func() db.Repository[model.Trade]); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(db.Repository[model.Trade])
		}
	}
	return r0
}

// MockStore_Trades_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Trades'
type MockStore_Trades_Call struct {
	*mock.Call
}

// Trades is a helper method to define mock.On call
func (_e *MockStore_Expecter) Trades() *MockStore_Trades_Call {
	return &MockStore_Trades_Call{Call: _e.mock.On("Trades")}
}

func (_c *MockStore_Trades_Call) Run(run func()) *MockStore_Trades_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_Trades_Call) Return(repository db.Repository[model.Trade]) *MockStore_Trades_Call {
	_c.Call.Return(repository)
	return _c
}

func (_c *MockStore_Trades_Call) RunAndReturn(run func() db.Repository[model.Trade]) *MockStore_Trades_Call {
	_c.Call.Return(run)
	return _c
}

// Wallet provides a mock function for the type MockStore
func (_mock *MockStore) Wallet() db.Repository[model.Wallet] {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Wallet")
	}

	var r0 db.Repository[model.Wallet]
	if returnFunc, ok := ret.Get(0).(func() db.Repository[model.Wallet]); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(db.Repository[model.Wallet])
		}
	}
	return r0
}

// MockStore_Wallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Wallet'
type MockStore_Wallet_Call struct {
	*mock.Call
}

// Wallet is a helper method to define mock.On call
func (_e *MockStore_Expecter) Wallet() *MockStore_Wallet_Call {
	return &MockStore_Wallet_Call{Call: _e.mock.On("Wallet")}
}

func (_c *MockStore_Wallet_Call) Run(run func()) *MockStore_Wallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_Wallet_Call) Return(repository db.Repository[model.Wallet]) *MockStore_Wallet_Call {
	_c.Call.Return(repository)
	return _c
}

func (_c *MockStore_Wallet_Call) RunAndReturn(run func() db.Repository[model.Wallet]) *MockStore_Wallet_Call {
	_c.Call.Return(run)
	return _c
}

// WithTransaction provides a mock function for the type MockStore
func (_mock *MockStore) WithTransaction(ctx context.Context, fn func(s db.Store) error) error {
	ret := _mock.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for WithTransaction")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(s db.Store) error) error); ok {
		r0 = returnFunc(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_WithTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTransaction'
type MockStore_WithTransaction_Call struct {
	*mock.Call
}

// WithTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(s db.Store) error
func (_e *MockStore_Expecter) WithTransaction(ctx interface{}, fn interface{}) *MockStore_WithTransaction_Call {
	return &MockStore_WithTransaction_Call{Call: _e.mock.On("WithTransaction", ctx, fn)}
}

func (_c *MockStore_WithTransaction_Call) Run(run func(ctx context.Context, fn func(s db.Store) error)) *MockStore_WithTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(s db.Store) error
		if args[1] != nil {
			arg1 = args[1].(func(s db.Store) error)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_WithTransaction_Call) Return(err error) *MockStore_WithTransaction_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_WithTransaction_Call) RunAndReturn(run func(ctx context.Context, fn func(s db.Store) error) error) *MockStore_WithTransaction_Call {
	_c.Call.Return(run)
	return _c
}
