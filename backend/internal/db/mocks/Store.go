// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package dbMocks

import (
	"context"

	"github.com/nicolas-martin/dankfolio/backend/internal/db"
	"github.com/nicolas-martin/dankfolio/backend/internal/model"
	mock "github.com/stretchr/testify/mock"
)

// NewMockStore creates a new instance of MockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStore {
	mock := &MockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStore is an autogenerated mock type for the Store type
type MockStore struct {
	mock.Mock
}

type MockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStore) EXPECT() *MockStore_Expecter {
	return &MockStore_Expecter{mock: &_m.Mock}
}

// Coins provides a mock function for the type MockStore
func (_mock *MockStore) Coins() db.Repository[model.Coin] {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Coins")
	}

	var r0 db.Repository[model.Coin]
	if returnFunc, ok := ret.Get(0).(func() db.Repository[model.Coin]); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(db.Repository[model.Coin])
		}
	}
	return r0
}

// MockStore_Coins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Coins'
type MockStore_Coins_Call struct {
	*mock.Call
}

// Coins is a helper method to define mock.On call
func (_e *MockStore_Expecter) Coins() *MockStore_Coins_Call {
	return &MockStore_Coins_Call{Call: _e.mock.On("Coins")}
}

func (_c *MockStore_Coins_Call) Run(run func()) *MockStore_Coins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_Coins_Call) Return(repository db.Repository[model.Coin]) *MockStore_Coins_Call {
	_c.Call.Return(repository)
	return _c
}

func (_c *MockStore_Coins_Call) RunAndReturn(run func() db.Repository[model.Coin]) *MockStore_Coins_Call {
	_c.Call.Return(run)
	return _c
}

// ListTrendingCoins provides a mock function for the type MockStore
func (_mock *MockStore) ListTrendingCoins(ctx context.Context) ([]model.Coin, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListTrendingCoins")
	}

	var r0 []model.Coin
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]model.Coin, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []model.Coin); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Coin)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_ListTrendingCoins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTrendingCoins'
type MockStore_ListTrendingCoins_Call struct {
	*mock.Call
}

// ListTrendingCoins is a helper method to define mock.On call
//   - ctx
func (_e *MockStore_Expecter) ListTrendingCoins(ctx interface{}) *MockStore_ListTrendingCoins_Call {
	return &MockStore_ListTrendingCoins_Call{Call: _e.mock.On("ListTrendingCoins", ctx)}
}

func (_c *MockStore_ListTrendingCoins_Call) Run(run func(ctx context.Context)) *MockStore_ListTrendingCoins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_ListTrendingCoins_Call) Return(coins []model.Coin, err error) *MockStore_ListTrendingCoins_Call {
	_c.Call.Return(coins, err)
	return _c
}

func (_c *MockStore_ListTrendingCoins_Call) RunAndReturn(run func(ctx context.Context) ([]model.Coin, error)) *MockStore_ListTrendingCoins_Call {
	_c.Call.Return(run)
	return _c
}

// RawCoins provides a mock function for the type MockStore
func (_mock *MockStore) RawCoins() db.Repository[model.RawCoin] {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RawCoins")
	}

	var r0 db.Repository[model.RawCoin]
	if returnFunc, ok := ret.Get(0).(func() db.Repository[model.RawCoin]); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(db.Repository[model.RawCoin])
		}
	}
	return r0
}

// MockStore_RawCoins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RawCoins'
type MockStore_RawCoins_Call struct {
	*mock.Call
}

// RawCoins is a helper method to define mock.On call
func (_e *MockStore_Expecter) RawCoins() *MockStore_RawCoins_Call {
	return &MockStore_RawCoins_Call{Call: _e.mock.On("RawCoins")}
}

func (_c *MockStore_RawCoins_Call) Run(run func()) *MockStore_RawCoins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_RawCoins_Call) Return(repository db.Repository[model.RawCoin]) *MockStore_RawCoins_Call {
	_c.Call.Return(repository)
	return _c
}

func (_c *MockStore_RawCoins_Call) RunAndReturn(run func() db.Repository[model.RawCoin]) *MockStore_RawCoins_Call {
	_c.Call.Return(run)
	return _c
}

// SearchCoins provides a mock function for the type MockStore
func (_mock *MockStore) SearchCoins(ctx context.Context, query string, tags []string, minVolume24h float64, limit int32, offset int32, sortBy string, sortDesc bool) ([]model.Coin, error) {
	ret := _mock.Called(ctx, query, tags, minVolume24h, limit, offset, sortBy, sortDesc)

	if len(ret) == 0 {
		panic("no return value specified for SearchCoins")
	}

	var r0 []model.Coin
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []string, float64, int32, int32, string, bool) ([]model.Coin, error)); ok {
		return returnFunc(ctx, query, tags, minVolume24h, limit, offset, sortBy, sortDesc)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []string, float64, int32, int32, string, bool) []model.Coin); ok {
		r0 = returnFunc(ctx, query, tags, minVolume24h, limit, offset, sortBy, sortDesc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Coin)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, []string, float64, int32, int32, string, bool) error); ok {
		r1 = returnFunc(ctx, query, tags, minVolume24h, limit, offset, sortBy, sortDesc)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_SearchCoins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchCoins'
type MockStore_SearchCoins_Call struct {
	*mock.Call
}

// SearchCoins is a helper method to define mock.On call
//   - ctx
//   - query
//   - tags
//   - minVolume24h
//   - limit
//   - offset
//   - sortBy
//   - sortDesc
func (_e *MockStore_Expecter) SearchCoins(ctx interface{}, query interface{}, tags interface{}, minVolume24h interface{}, limit interface{}, offset interface{}, sortBy interface{}, sortDesc interface{}) *MockStore_SearchCoins_Call {
	return &MockStore_SearchCoins_Call{Call: _e.mock.On("SearchCoins", ctx, query, tags, minVolume24h, limit, offset, sortBy, sortDesc)}
}

func (_c *MockStore_SearchCoins_Call) Run(run func(ctx context.Context, query string, tags []string, minVolume24h float64, limit int32, offset int32, sortBy string, sortDesc bool)) *MockStore_SearchCoins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].(float64), args[4].(int32), args[5].(int32), args[6].(string), args[7].(bool))
	})
	return _c
}

func (_c *MockStore_SearchCoins_Call) Return(coins []model.Coin, err error) *MockStore_SearchCoins_Call {
	_c.Call.Return(coins, err)
	return _c
}

func (_c *MockStore_SearchCoins_Call) RunAndReturn(run func(ctx context.Context, query string, tags []string, minVolume24h float64, limit int32, offset int32, sortBy string, sortDesc bool) ([]model.Coin, error)) *MockStore_SearchCoins_Call {
	_c.Call.Return(run)
	return _c
}

// Trades provides a mock function for the type MockStore
func (_mock *MockStore) Trades() db.Repository[model.Trade] {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Trades")
	}

	var r0 db.Repository[model.Trade]
	if returnFunc, ok := ret.Get(0).(func() db.Repository[model.Trade]); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(db.Repository[model.Trade])
		}
	}
	return r0
}

// MockStore_Trades_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Trades'
type MockStore_Trades_Call struct {
	*mock.Call
}

// Trades is a helper method to define mock.On call
func (_e *MockStore_Expecter) Trades() *MockStore_Trades_Call {
	return &MockStore_Trades_Call{Call: _e.mock.On("Trades")}
}

func (_c *MockStore_Trades_Call) Run(run func()) *MockStore_Trades_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_Trades_Call) Return(repository db.Repository[model.Trade]) *MockStore_Trades_Call {
	_c.Call.Return(repository)
	return _c
}

func (_c *MockStore_Trades_Call) RunAndReturn(run func() db.Repository[model.Trade]) *MockStore_Trades_Call {
	_c.Call.Return(run)
	return _c
}

// Wallet provides a mock function for the type MockStore
func (_mock *MockStore) Wallet() db.Repository[model.Wallet] {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Wallet")
	}

	var r0 db.Repository[model.Wallet]
	if returnFunc, ok := ret.Get(0).(func() db.Repository[model.Wallet]); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(db.Repository[model.Wallet])
		}
	}
	return r0
}

// MockStore_Wallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Wallet'
type MockStore_Wallet_Call struct {
	*mock.Call
}

// Wallet is a helper method to define mock.On call
func (_e *MockStore_Expecter) Wallet() *MockStore_Wallet_Call {
	return &MockStore_Wallet_Call{Call: _e.mock.On("Wallet")}
}

func (_c *MockStore_Wallet_Call) Run(run func()) *MockStore_Wallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_Wallet_Call) Return(repository db.Repository[model.Wallet]) *MockStore_Wallet_Call {
	_c.Call.Return(repository)
	return _c
}

func (_c *MockStore_Wallet_Call) RunAndReturn(run func() db.Repository[model.Wallet]) *MockStore_Wallet_Call {
	_c.Call.Return(run)
	return _c
}

// WithTransaction provides a mock function for the type MockStore
func (_mock *MockStore) WithTransaction(ctx context.Context, fn func(s db.Store) error) error {
	ret := _mock.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for WithTransaction")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(s db.Store) error) error); ok {
		r0 = returnFunc(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_WithTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTransaction'
type MockStore_WithTransaction_Call struct {
	*mock.Call
}

// WithTransaction is a helper method to define mock.On call
//   - ctx
//   - fn
func (_e *MockStore_Expecter) WithTransaction(ctx interface{}, fn interface{}) *MockStore_WithTransaction_Call {
	return &MockStore_WithTransaction_Call{Call: _e.mock.On("WithTransaction", ctx, fn)}
}

func (_c *MockStore_WithTransaction_Call) Run(run func(ctx context.Context, fn func(s db.Store) error)) *MockStore_WithTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(func(s db.Store) error))
	})
	return _c
}

func (_c *MockStore_WithTransaction_Call) Return(err error) *MockStore_WithTransaction_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_WithTransaction_Call) RunAndReturn(run func(ctx context.Context, fn func(s db.Store) error) error) *MockStore_WithTransaction_Call {
	_c.Call.Return(run)
	return _c
}
